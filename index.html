<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        function mergeSort(array) {


        //with -1 on the array stuff
        function mergeAlgo(A, B, m, n) { //m = A.length, n = B.length
            let i = j = 0;
            let C = []; //empty array
            while (i < m && j < n) {
                if (A[i] < B[j]) {

                    C.push(A[i]);
                    i++;
                    //C[k++] = A[i++];
                } else {
                    
                    C.push(B[j]);
                    j++;
                    //C[k++] = B[j++];
                }
            }
            
            for (; i < m; i++) {
                C.push(A[i]);
                //C[k++] = A[i]; 
            };
            for (; j < n; j++) {
                C.push(B[j]);
                //C[k++] = B[j]; 
            };
            /* for (;i < m; i++) {
                C.push(A[i]);
                //C[k++] = A[i]; 
            };
            for (;j < n; n++) {
                C.push(B[j]);
                //C[k++] = B[j]; 
            }; */
            return C;
        }

        if (array.length === 1) {
            return array;
        } else {
            // #1 separate an array into halves
            // #2 
            // #3 weave them together

            // #1
            let length = array.length; //ex: 5 [0,1,2,3,4]
            let start = mid1 = 0;
            let halfway = length/2; //5 div 2 == 2.5
            if (!Number.isInteger(halfway)) {
                mid1 = Math.floor(halfway); //2; round down to split odd numbered arrays
            } else {
                mid1 = halfway;
            }
            let end = length; //5
            let firstHalf = array.slice(start, mid1);
            let secondHalf = array.slice(mid1, end);

            //splits original array in halves, UNSORTED

            // #2 
            // sort each array
            let sortedFirstHalf = mergeSort(firstHalf);
            let sortedSecondHalf = mergeSort(secondHalf);

            // #3
            // Two sorted, now merge

            let holderArray = mergeAlgo(sortedFirstHalf, sortedSecondHalf, sortedFirstHalf.length, sortedSecondHalf.length);
            //return mergeSort();//doing this will cause SOF - array length will NOT change and base case won't be reached

            return holderArray;
            }
        }

        const Node = function(x) {
            this.value = x;
            this.left = null; //type Node
            this.right = null; //type Node

            /* this.setLeft = (lNode) => {
                this.left = lNode;
            }
            this.setRight = (rNode) => {
                this.right = rNode;
            } */
        }

        const Tree = function() {

            this.root = null; //type Node
            this.nodeHolder1 = null; //type Node
            this.nodeHolder2 = null; //type Node
            this.nodeHolder3 = null; //type Node
            this.boolean = null;
            this.buildTree = (x) => {
                //[2,5,6,2,25,13]

                //remove duplicate values
                let noRepeats = x.filter((value, index, array) => array.indexOf(value) === index);
                //filtered: [2,5,6,25,13];
                //sort low to high
                let sortedFiltered = mergeSort(noRepeats);
                //sorted: [2,5,6,13,25]

                let start = 0;
                let end = sortedFiltered.length-1; //4; 0-based index

                function createBST(rArray, rStart, rEnd) {
                    //array is sortedFiltered
                    //rStart begins with 0, rEnd begins with value of 4
                    if (rStart > rEnd) {
                        return null;
                    } 
                    let rMid = Math.floor((rStart + rEnd)/2);

                    let newNode = new Node(rArray[rMid]);
                    newNode.left = (createBST(rArray, rStart, rMid-1));
                    newNode.right = (createBST(rArray, rMid+1, rEnd));
                    
                    this.root = newNode;
                    return newNode;
                }
                this.root = createBST(sortedFiltered, start, end);
                return this.root;
            }//end of buildTree fxn

            prettyPrint = (node, prefix = '', isLeft = true) => {
                if (node.right !== null) {
                    prettyPrint(node.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);
                }
                console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${node.value}`);
                if (node.left !== null) {
                    prettyPrint(node.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);
                }
            }

            compareNode = (node, input) => {
                //BASE CASE: once the direction I want to go has reached null
                //recursion: keep going down direction of comparing input to node.value
                //check if value is greater/less than value at root                
                //if greater than, go .right (and if less than, go .left)
                //repeat process until either 1) same value is found or 2) null is reached
                //1) if same val found, return console.log("Cannot add value as value already exists within tree")
                //2) if null is reached, take that current node (that you used to REACH null w/ .left/.right)
                //and set respective .left/.right to newNode
                if (node === null) {//reached empty
                    let newNode = new Node(input);
                    console.log("reached null, return");
                    return newNode;
                } else if (node.value === input) {
                    console.log("Cannot add value as value already exists within tree");
                } else if (node.value > input) {//input is smaller, go left
                    node.left = compareNode(node.left, input);
                } else if (node.value < input) {//input is larger, go right
                    node.right = compareNode(node.right, input);
                }
                return node;
            }

            insertValue = (value) => {//should only add as a LEAF
                //ex: add 69
                let startNode = this.root;
                compareNode(startNode, value);
            }

            contains = (node, input) => {
                console.log(node);
                if (node === null) {
                    console.log("Hit null; value is not within tree");
                    this.boolean = false;
                    return;
                } else if (node.value === input) {
                    console.log("found value");
                    this.boolean = true;
                } else if (node.value > input) {//input is smaller, go left
                    if (node.left === null) {
                        console.log("node.left equalled null, value is lower than what is in tree");
                        this.boolean = false;
                        return;
                    } else {
                        contains(node.left, input);
                    }
                } else if (node.value < input) {//input is larger, go right
                    if (node.right === null) {
                        console.log("node.right equalled null, value is higher than what is in tree");
                        this.boolean = false;
                        return;
                    } else {
                        contains(node.right, input);
                    }
                }
                return this.boolean;
            }

            checkIfPresent = (value) => {//should return boolean true/false
                let startNode = this.root;
                return contains(startNode, value);
            }

            whichNode = (node, input) => {
                console.log(node);
                if (node.value === input) {
                    console.log("found value");
                    this.nodeHolder1 = node;
                } else if (node.value > input) {//input is smaller, go left
                    whichNode(node.left, input);
                } else if (node.value < input) {//input is larger, go right
                    whichNode(node.right, input);
                }
                return this.nodeHolder1;
            }

            findNode = (value) => {
                let startNode = this.root;
                if (!contains(startNode, value)) {
                    console.log("Unable to find Node with given value");
                    return undefined;
                } else {
                    return whichNode(startNode, value);
                }
            }

            //start at root node; if value is less than root's, go left, else go right
            //follow recursively until either 1) value is found
            //2) no value is found, return null & console.log("This value does not exist within the tree")
            //once value is found, assign the prior node's (before the leaf) .left/.right to be null
            //BASE case: when node === null ? or when node.value === input

            //when searching for node, write so that before another recursion occurs
            //check the value of node.left/.right and see if it matches...?

            removeLeaf = (node, input) => {//jank code with a lot of if/else's
                console.log(node);
                if (node.value > input) {//input smaller, go left
                    //node.left = removeLeaf(node.left, input);
                    if (node.left === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.left.value === input) {
                        console.log("Found the value!");
                        node.left = null;
                    } else {
                        node.left = removeLeaf(node.left, input);
                    }                    
                } else if (node.value < input) {//input larger, go right
                    //node.right = removeLeaf(node.right, input);
                    if (node.right === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.right.value === input) {
                        console.log("Found the value!");
                        node.right = null;
                    } else {
                        node.right = removeLeaf(node.right, input);
                    }   
                } 
                return node;
            }

            /*Write delete function which accepts a value to delete 
            (you’ll have to deal with several USE CASES for delete -- 
            such as when a node has children or not).*/
            deleteValue = (value) => {
                if (!checkIfPresent(value)) {
                    console.log("Cannot delete as value is not within tree");
                } else {
                    //ex: delete 13 (NOT a leaf)
                    //ex: delete 25 (a leaf)
                    let startNode = this.root;
                    //removeLeaf(startNode, value);
                    removeAlgo(startNode, value);
                }
                
            }

            removeAlgo = (node, input) => {
                //for leaf
                //BASE CASE, ideally, is when recursion has gotten to node.value === input
                //can make that base case return null
                //for non-leaf scenarios: BASE CASE is same
                //ideally would use 3 holders, one for the node BEFORE base case is reached, target node, and
                //one holder to be set at base case node.left/.right

                console.log(node);
                if (node === null) {//for leaf node
                    console.log("Number not found in tree");
                    return null;
                } else if (node.value === input) {
                    if (node.right === null && node.left === null) {//there are NO children; leaf node scenario
                        console.log("Hit base case");
                        return null;
                    } else if (node.right !== null) {//1 right child leaf present
                        this.nodeHolder2 = node;
                        this.nodeHolder3 = node.right;
                        return;
                    } else if (node.left !== null) {//1 left child leaf present
                        this.nodeHolder2 = node;
                        this.nodeHolder3 = node.left;
                        return;
                    }
                } else if (node.value > input) {//input smaller, go left
                    if (node.left.value === input) {
                        console.log("nodeHolder 1 set here");
                        this.nodeHolder1 = node;
                    }
                    node.left = removeAlgo(node.left, input);
                    /* if (node.left === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.left.value === input) {
                        console.log("Found the value!");
                        node.left = null;
                    } else {
                        node.left = removeLeaf(node.left, input);
                    }       */              
                } else if (node.value < input) {//input larger, go right
                    if (node.right.value === input) {
                        console.log("nodeHolder 1 set here");
                        this.nodeHolder1 = node;
                    }
                    node.right = removeAlgo(node.right, input);
                    
                    
                    /* if (node.right === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.right.value === input) {
                        console.log("Found the value!");
                        node.right = null;
                    } else {
                        node.right = removeLeaf(node.right, input);
                    }    */
                } 
                
                console.log(this.nodeHolder1);
                console.log(this.nodeHolder2);
                console.log(this.nodeHolder3);

                if (node === this.nodeHolder1 && (this.nodeHolder2 !== null && this.nodeHolder3 !== null)) {
                    //makes sure that nodeHolders 2 & 3 are assigned
                    //means that the algorithm went through scenario of 1 child leaf (target node 2 sandwiched)
                    if (this.nodeHolder1.value < this.nodeHolder2.value) {
                        this.nodeHolder1.right = this.nodeHolder3;
                    } else {
                        this.nodeHolder1.left = this.nodeHolder3;
                    }
                }
                return node;
            }

            testFunctionConsoleSelf = (node) => {
                console.log(node.value);
            }

            /*Write a levelOrder function which accepts another function as a parameter. 
            levelOrder should traverse the tree in breadth-first level order and provide 
            each node as the argument to the provided function. 
            This function can be implemented using either iteration or recursion 
            (try implementing both!). The method should return an array of values 
            if no function is given. Tip: You will want to use an array acting as 
            a queue to keep track of all the child nodes that you have yet to 
            traverse and to add new ones to the list */

            levelOrderRecursion = (node, array, funct) => {
                array.push(node); //first, push current node onto Q
                if (node === null) {
                    console.log("reached an end");
                    return;
                } else {
                    //access current node value
                    console.log(node.value);
                    //add node's children leaves to Q
                    if (node.right !== null) {
                        console.log(node.right);
                        array.push(node.right);
                        //levelOrderRecursion(node.right, array, funct);
                        //currently this method will push all the R side then L side, DEPTH-first
                    } 
                    
                    if (node.left !== null) {
                        console.log(node.left);
                        array.push(node.left);
                        //levelOrderRecursion(node.left, array, funct);
                    }
                    //remove parent node from Q
                    array.shift();
                }
                return array;
            }

            levelOrder = (somefunction) => {
                let startNode = this.root;
                let queueArray = [];

                console.log(levelOrderRecursion(startNode, queueArray, somefunction));
                return queueArray;
            }

        }
        
        const testArray = [2,5,6,2,25,13];
        const test = new Tree();
        test.buildTree(testArray);
        console.log(test.root);
        prettyPrint(test.root);
        //console.log(checkIfPresent(25)); //returns a boolean true/false
        //deleteValue(13); //currently code will break if val here is NOT within tree
        //insertValue(13); //will not add duplicates; adds as leaf
        //console.log(findNode(13)); //returns node with inputted value or undefined if not there

        //console.log(levelOrder());
        /* prettyPrint(test.root);
        console.log(test.root); */
    </script>
</body>
</html>