<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        function mergeSort(array) {


        //with -1 on the array stuff
        function mergeAlgo(A, B, m, n) { //m = A.length, n = B.length
            let i = j = 0;
            let C = []; //empty array
            while (i < m && j < n) {
                if (A[i] < B[j]) {

                    C.push(A[i]);
                    i++;
                    //C[k++] = A[i++];
                } else {
                    
                    C.push(B[j]);
                    j++;
                    //C[k++] = B[j++];
                }
            }
            
            for (; i < m; i++) {
                C.push(A[i]);
                //C[k++] = A[i]; 
            };
            for (; j < n; j++) {
                C.push(B[j]);
                //C[k++] = B[j]; 
            };
            /* for (;i < m; i++) {
                C.push(A[i]);
                //C[k++] = A[i]; 
            };
            for (;j < n; n++) {
                C.push(B[j]);
                //C[k++] = B[j]; 
            }; */
            return C;
        }

        if (array.length === 1) {
            return array;
        } else {
            // #1 separate an array into halves
            // #2 
            // #3 weave them together

            // #1
            let length = array.length; //ex: 5 [0,1,2,3,4]
            let start = mid1 = 0;
            let halfway = length/2; //5 div 2 == 2.5
            if (!Number.isInteger(halfway)) {
                mid1 = Math.floor(halfway); //2; round down to split odd numbered arrays
            } else {
                mid1 = halfway;
            }
            let end = length; //5
            let firstHalf = array.slice(start, mid1);
            let secondHalf = array.slice(mid1, end);

            //splits original array in halves, UNSORTED

            // #2 
            // sort each array
            let sortedFirstHalf = mergeSort(firstHalf);
            let sortedSecondHalf = mergeSort(secondHalf);

            // #3
            // Two sorted, now merge

            let holderArray = mergeAlgo(sortedFirstHalf, sortedSecondHalf, sortedFirstHalf.length, sortedSecondHalf.length);
            //return mergeSort();//doing this will cause SOF - array length will NOT change and base case won't be reached

            return holderArray;
            }
        }

        const Node = function(x) {
            this.value = x;
            this.left = null; //type Node
            this.right = null; //type Node

            /* this.setLeft = (lNode) => {
                this.left = lNode;
            }
            this.setRight = (rNode) => {
                this.right = rNode;
            } */
        }

        const Tree = function() {

            this.root = null; //type Node
            this.holder = null; //type Node
            this.buildTree = (x) => {
                //[2,5,6,2,25,13]

                //remove duplicate values
                let noRepeats = x.filter((value, index, array) => array.indexOf(value) === index);
                //filtered: [2,5,6,25,13];
                //sort low to high
                let sortedFiltered = mergeSort(noRepeats);
                //sorted: [2,5,6,13,25]

                let start = 0;
                let end = sortedFiltered.length-1; //4; 0-based index

                function createBST(rArray, rStart, rEnd) {
                    //array is sortedFiltered
                    //rStart begins with 0, rEnd begins with value of 4
                    if (rStart > rEnd) {
                        return null;
                    } 
                    let rMid = Math.floor((rStart + rEnd)/2);

                    let newNode = new Node(rArray[rMid]);
                    newNode.left = (createBST(rArray, rStart, rMid-1));
                    newNode.right = (createBST(rArray, rMid+1, rEnd));
                    
                    this.root = newNode;
                    return newNode;
                }
                this.root = createBST(sortedFiltered, start, end);
                return this.root;
            }//end of buildTree fxn

            prettyPrint = (node, prefix = '', isLeft = true) => {
                if (node.right !== null) {
                    prettyPrint(node.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);
                }
                console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${node.value}`);
                if (node.left !== null) {
                    prettyPrint(node.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);
                }
            }

            compareNode = (node, input) => {
                //BASE CASE: once the direction I want to go has reached null
                //recursion: keep going down direction of comparing input to node.value
                //check if value is greater/less than value at root                
                //if greater than, go .right (and if less than, go .left)
                //repeat process until either 1) same value is found or 2) null is reached
                //1) if same val found, return console.log("Cannot add value as value already exists within tree")
                //2) if null is reached, take that current node (that you used to REACH null w/ .left/.right)
                //and set respective .left/.right to newNode
                if (node === null) {//reached empty
                    let newNode = new Node(input);
                    console.log("reached null, return");
                    return newNode;
                } else if (node.value === input) {
                    console.log("Cannot add value as value already exists within tree");
                } else if (node.value > input) {//input is smaller, go left
                    node.left = compareNode(node.left, input);
                } else if (node.value < input) {//input is larger, go right
                    node.right = compareNode(node.right, input);
                }
                return node;
            }

            insertValue = (value) => {//should only add as a LEAF
                //ex: add 69
                let startNode = this.root;
                compareNode(startNode, value);
            }

            contains = (node, input) => {
                console.log(node);
                if (node === null) {
                    console.log("Hit null; value is not within tree");
                    return false;
                } else if (node.value > input) {//input is smaller, go left
                    if (node.left === null) {
                        console.log("node.left equalled null, value is lower than what is in tree");
                        return false;
                    } else {
                        contains(node.left, input);
                    }
                } else if (node.value < input) {//input is larger, go right
                    if (node.right === null) {
                        console.log("node.right equalled null, value is higher than what is in tree");
                        return false;
                    } else {
                        contains(node.right, input);
                    }
                }
            }

            checkIfPresent = (value) => {//should return boolean true/false
                let startNode = this.root;
                return contains(startNode, value);
            }

            //start at root node; if value is less than root's, go left, else go right
            //follow recursively until either 1) value is found
            //2) no value is found, return null & console.log("This value does not exist within the tree")
            //once value is found, assign the prior node's (before the leaf) .left/.right to be null
            //BASE case: when node === null ? or when node.value === input

            //when searching for node, write so that before another recursion occurs
            //check the value of node.left/.right and see if it matches...?

            removeLeaf = (node, input) => {
                console.log(node);
                if (node.value > input) {//input smaller, go left
                    //node.left = removeLeaf(node.left, input);
                    if (node.left === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.left.value === input) {
                        console.log("Found the value!");
                        node.left = null;
                    } else {
                        node.left = removeLeaf(node.left, input);
                    }                    
                } else if (node.value < input) {//input larger, go right
                    //node.right = removeLeaf(node.right, input);
                    if (node.right === null) {
                        console.log("This value does not exist within the tree");
                    } else if (node.right.value === input) {
                        console.log("Found the value!");
                        node.right = null;
                    } else {
                        node.right = removeLeaf(node.right, input);
                    }   
                } 
                return node;
            }

            /*Write delete function which accepts a value to delete 
            (you’ll have to deal with several USE CASES for delete -- 
            such as when a node has children or not).*/
            deleteValue = (value) => {
                //ex: delete 13 (NOT a leaf)
                //ex: delete 25 (a leaf)
                let startNode = this.root;
                removeLeaf(startNode, value);
            }

        }
        
        const testArray = [2,5,6,2,25,13];
        const test = new Tree();
        test.buildTree(testArray);
        console.log(test.root);
        prettyPrint(test.root);
        //checkIfPresent(100);
        //console.log(checkIfPresent(100));
        deleteValue(42); //currently code will break if val here is NOT within tree
        //insertValue(1);
        prettyPrint(test.root);
        console.log(test.root);
    </script>
</body>
</html>